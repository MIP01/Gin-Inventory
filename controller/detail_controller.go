package controller

import (
	"fmt"
	"gin_iventory/config"
	"gin_iventory/middleware"
	"gin_iventory/model"
	"time"

	"github.com/gin-gonic/gin"
)

func CreateDetailHandler(c *gin.Context) {
	role, roleExists := c.Get("role")
	if !roleExists || role != "user" {
		c.JSON(403, gin.H{"error": "Unauthorized"})
		return
	}

	// Ambil current_user_id dari context
	currentUserID, userExists := c.Get("current_id")
	if !userExists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	var detailData middleware.DetailSchema
	if err := c.ShouldBindJSON(&detailData); err != nil {
		errors := middleware.FormatValidationErrors(err)
		c.JSON(400, gin.H{"errors": errors})
		return
	}

	validationErrors := middleware.ValidateInput(detailData)
	if validationErrors != nil {
		c.JSON(400, gin.H{"errors": validationErrors})
		return
	}

	// Cari transaksi milik current_user dengan status 'draft'
	var transaction model.Transaction
	if err := config.DB.Where("user_id = ? AND status = ?", currentUserID, "draft").First(&transaction).Error; err != nil {
		c.JSON(404, gin.H{"error": "No draft transaction found for the current user"})
		return
	}

	// Cari item terkait berdasarkan ItemID dalam transaksi
	var item model.Item
	if err := config.DB.First(&item, transaction.ItemID).Error; err != nil {
		c.JSON(404, gin.H{"error": "Item not found for the transaction"})
		return
	}

	// Buat kode secara otomatis
	autoGeneratedCode := fmt.Sprintf("ivt%d%d%d", transaction.ID, item.ID, currentUserID.(uint))

	newDetail := model.Detail{
		Code:   autoGeneratedCode,
		Out:    detailData.Out,
		Entry:  detailData.Entry,
		Status: "pending",
	}

	if err := config.DB.Create(&newDetail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Perbarui kolom DetailID dan Status pada transaksi
	transaction.DetailID = &newDetail.ID
	transaction.Status = "pending" // Ubah status
	if err := config.DB.Save(&transaction).Error; err != nil {
		c.JSON(500, gin.H{"error": "Failed to update transaction with detail ID and status"})
		return
	}

	c.JSON(201, gin.H{"message": "Detail created successfully", "detail": newDetail.ToMap()})
}

func GetAllDetailHandler(c *gin.Context) {
	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists {
		c.JSON(403, gin.H{"error": "Forbidden: Role is not specified"})
		return
	}

	var details []struct {
		Code     string    `json:"code"`
		Out      time.Time `json:"out"`
		Entry    time.Time `json:"entry"`
		Status   string    `json:"status"`
		Quantity int       `json:"quantity"`
		ItemName string    `json:"item_name"`
	}

	query := config.DB.Table("details").
		Select("details.code, details.out, details.entry, details.status, transactions.quantity, items.name AS item_name").
		Joins("LEFT JOIN transactions ON transactions.detail_id = details.id").
		Joins("LEFT JOIN items ON items.id = transactions.item_id")

	if role == "user" {
		query = query.Where("transactions.user_id = ?", currentUserID)
	}

	if err := query.Scan(&details).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"details": details})
}

func GetDetailHandler(c *gin.Context) {
	// Ambil ID detail dari parameter URL
	id := c.Param("id")

	// Ambil current_id dan role dari context (diset oleh middleware)
	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists || (role != "admin" && id != fmt.Sprint(currentUserID)) {
		c.JSON(403, gin.H{"error": "Forbidden: You can only access your own data"})
		return
	}

	// Definisikan struktur untuk hasil query
	var detail struct {
		Code     string    `json:"code"`
		Out      time.Time `json:"out"`
		Entry    time.Time `json:"entry"`
		Status   string    `json:"status"`
		Quantity int       `json:"quantity"`
		ItemName string    `json:"item_name"`
	}

	// Query dengan join untuk mendapatkan data yang dibutuhkan
	err := config.DB.Table("details").
		Select("details.code, details.out, details.entry, details.status, transactions.quantity, items.name AS item_name").
		Joins("LEFT JOIN transactions ON transactions.detail_id = details.id").
		Joins("LEFT JOIN items ON items.id = transactions.item_id").
		Where("details.id = ?", id).
		Scan(&detail).Error

	if err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Kembalikan hasil dalam format JSON
	c.JSON(200, gin.H{"detail": detail})
}

func UpdateDetailHandler(c *gin.Context) {
	id := c.Param("id")

	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists || (role != "admin" && id != fmt.Sprint(currentUserID)) {
		c.JSON(403, gin.H{"error": "Forbidden: You can only access your own data"})
		return
	}

	// Pastikan detail ada
	var detail model.Detail
	if err := config.DB.First(&detail, id).Error; err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Memvalidasi input dengan Middleware ValidateInput.
	var updatedData middleware.DetailSchema
	if err := c.ShouldBindJSON(&updatedData); err != nil {
		errors := middleware.FormatValidationErrors(err)
		c.JSON(400, gin.H{"errors": errors})
		return
	}

	validationErrors := middleware.ValidateInput(updatedData)
	if validationErrors != nil {
		c.JSON(400, gin.H{"errors": validationErrors})
		return
	}

	// Menyimpan status sebelumnya
	previousStatus := detail.Status

	// Jika user dan status adalah pending, izinkan perubahan Out dan Entry
	if role == "user" && detail.Status == "pending" {
		if !updatedData.Out.IsZero() {
			detail.Out = updatedData.Out
		}
		if !updatedData.Entry.IsZero() {
			detail.Entry = updatedData.Entry
		}
	}

	// Jika admin, hanya bisa mengubah status
	if role == "admin" {
		if updatedData.Status != "" {
			detail.Status = updatedData.Status
		}

		// Jika status berubah dari 'pending' ke 'loaned', kurangi quantity dari stok item
		if previousStatus == "pending" && detail.Status == "loaned" {
			var item model.Item
			if err := config.DB.First(&item, detail.Transactions[0].ItemID).Error; err != nil {
				c.JSON(404, gin.H{"error": "Item not found"})
				return
			}

			// Kurangi stok jika status berubah dari pending ke loaned
			if item.Stock >= detail.Transactions[0].Quantity {
				item.Stock -= detail.Transactions[0].Quantity
				if err := config.DB.Save(&item).Error; err != nil {
					c.JSON(500, gin.H{"error": "Failed to update item stock"})
					return
				}
			} else {
				c.JSON(400, gin.H{"error": "Not enough stock available"})
				return
			}
		}

		// Jika status berubah dari 'loaned' ke 'return' atau 'pending', kembalikan quantity ke stok
		if previousStatus == "loaned" && (detail.Status == "return" || detail.Status == "pending" || detail.Status == "rejected") {
			var item model.Item
			if err := config.DB.First(&item, detail.Transactions[0].ItemID).Error; err != nil {
				c.JSON(404, gin.H{"error": "Item not found"})
				return
			}

			// Kembalikan stok jika status berubah menjadi 'return' atau 'pending'
			item.Stock += detail.Transactions[0].Quantity
			if err := config.DB.Save(&item).Error; err != nil {
				c.JSON(500, gin.H{"error": "Failed to update item stock"})
				return
			}
		}

		// Jika status berubah dari 'pending' ke 'rejected', tidak ada perubahan stok
		if previousStatus == "pending" && detail.Status == "rejected" {
			// Tidak ada tindakan yang diperlukan, hanya mengubah status
		}
	}

	// Simpan perubahan
	if err := config.DB.Save(&detail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "Detail updated successfully", "detail": detail.ToMap()})
}

func DeleteDetailHandler(c *gin.Context) {
	id := c.Param("id")

	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists || (role != "admin" && id != fmt.Sprint(currentUserID)) {
		c.JSON(403, gin.H{"error": "Forbidden: You can only access your own data"})
		return
	}

	// Pastikan detail ada
	var detail model.Detail
	if err := config.DB.First(&detail, id).Error; err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Periksa apakah status detail adalah pending atau rejected
	if detail.Status != "pending" && detail.Status != "rejected" {
		c.JSON(400, gin.H{"error": "Cannot delete detail: Detail status must be pending or rejected"})
		return
	}

	// Hapus transaksi yang terhubung dengan detail_id
	if err := config.DB.Where("detail_id = ?", id).Delete(&model.Transaction{}).Error; err != nil {
		c.JSON(500, gin.H{"error": "Failed to delete related transactions"})
		return
	}

	// Hapus detail
	if err := config.DB.Delete(&detail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "Detail and related transactions deleted successfully"})
}
