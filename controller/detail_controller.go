package controller

import (
	"fmt"
	"gin_iventory/config"
	"gin_iventory/middleware"
	"gin_iventory/model"
	"time"

	"github.com/gin-gonic/gin"
)

func CreateDetailHandler(c *gin.Context) {
	role, roleExists := c.Get("role")
	if !roleExists || role != "user" {
		c.JSON(403, gin.H{"error": "Unauthorized"})
		return
	}

	// Ambil current_user_id dari context
	currentUserID, userExists := c.Get("current_id")
	if !userExists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	var detailData middleware.DetailSchema
	if err := c.ShouldBindJSON(&detailData); err != nil {
		errors := middleware.FormatValidationErrors(err)
		c.JSON(400, gin.H{"errors": errors})
		return
	}

	validationErrors := middleware.ValidateInput(detailData)
	if validationErrors != nil {
		c.JSON(400, gin.H{"errors": validationErrors})
		return
	}

	// Cari transaksi milik current_user dengan status 'draft'
	var transaction model.Transaction
	if err := config.DB.Where("user_id = ? AND status = ?", currentUserID, "draft").First(&transaction).Error; err != nil {
		c.JSON(404, gin.H{"error": "No draft transaction found for the current user"})
		return
	}

	// Cari item terkait berdasarkan ItemID dalam transaksi
	var item model.Item
	if err := config.DB.First(&item, transaction.ItemID).Error; err != nil {
		c.JSON(404, gin.H{"error": "Item not found for the transaction"})
		return
	}

	// Buat kode secara otomatis
	autoGeneratedCode := fmt.Sprintf("ivt%d%d%d", transaction.ID, item.ID, currentUserID.(uint))

	// Konversi string "Out" dan "Entry" ke time.Time
	var outTime, entryTime time.Time
	var err error

	if detailData.Out != "" {
		outTime, err = time.Parse("2006-01-02", detailData.Out) // Konversi string ke time.Time
		if err != nil {
			c.JSON(400, gin.H{"error": "Invalid date format for Out"})
			return
		}
	}

	if detailData.Entry != "" {
		entryTime, err = time.Parse("2006-01-02", detailData.Entry) // Konversi string ke time.Time
		if err != nil {
			c.JSON(400, gin.H{"error": "Invalid date format for Entry"})
			return
		}
	}

	newDetail := model.Detail{
		Code:   autoGeneratedCode,
		Out:    outTime,
		Entry:  entryTime,
		Status: "pending",
	}

	if err := config.DB.Create(&newDetail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	// Perbarui kolom DetailID dan Status pada transaksi
	transaction.DetailID = &newDetail.ID
	transaction.Status = "pending" // Ubah status
	if err := config.DB.Save(&transaction).Error; err != nil {
		c.JSON(500, gin.H{"error": "Failed to update transaction with detail ID and status"})
		return
	}

	c.JSON(201, gin.H{"message": "Detail created successfully", "detail": newDetail.ToMap()})
}

func GetAllDetailHandler(c *gin.Context) {
	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists {
		c.JSON(403, gin.H{"error": "Forbidden: Role is not specified"})
		return
	}

	var detail []struct {
		ID       uint      `json:"detail_id"`
		Code     string    `json:"code"`
		Out      time.Time `json:"out"`
		Entry    time.Time `json:"entry"`
		Status   string    `json:"status"`
		Quantity int       `json:"quantity"`
		ItemName string    `json:"item_name"`
	}

	query := config.DB.Table("detail").
		Select("detail.id, detail.code, detail.out, detail.entry, detail.status, transaction.quantity, item.name AS item_name").
		Joins("LEFT JOIN transaction ON transaction.detail_id = detail.id").
		Joins("LEFT JOIN item ON item.id = transaction.item_id")

	if role == "user" {
		query = query.Where("transaction.user_id = ?", currentUserID)
	}

	if err := query.Scan(&detail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"detail": detail})
}

func GetDetailHandler(c *gin.Context) {
	// Ambil ID detail dari parameter URL
	detail_id := c.Param("detail_id")

	// Ambil current_id dan role dari context (diset oleh middleware)
	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists || (role != "admin" && detail_id != fmt.Sprint(currentUserID)) {
		c.JSON(403, gin.H{"error": "Forbidden: You can only access your own data"})
		return
	}

	// Definisikan struktur untuk hasil query
	var detail struct {
		Code     string    `json:"code"`
		Out      time.Time `json:"out"`
		Entry    time.Time `json:"entry"`
		Status   string    `json:"status"`
		Quantity int       `json:"quantity"`
		ItemName string    `json:"item_name"`
	}

	// Query dengan join untuk mendapatkan data yang dibutuhkan
	err := config.DB.Table("detail").
		Select("detail.code, detail.out, detail.entry, detail.status, transaction.quantity, item.name AS item_name").
		Joins("LEFT JOIN transaction ON transaction.detail_id = detail.id").
		Joins("LEFT JOIN item ON item.id = transaction.item_id").
		Where("detail.id = ?", detail_id).
		Scan(&detail).Error

	if err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Kembalikan hasil dalam format JSON
	c.JSON(200, gin.H{"detail": detail})
}

func UpdateDetailHandler(c *gin.Context) {
	detail_id := c.Param("detail_id")

	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists {
		c.JSON(403, gin.H{"error": "Forbidden: Role not found"})
		return
	}

	// Jika role adalah "user", hanya izinkan akses pada data miliknya
	if role == "user" && detail_id != fmt.Sprint(currentUserID) {
		c.JSON(403, gin.H{"error": "Forbidden: You can only access your own data"})
		return
	}

	// Jika role adalah "admin", izinkan akses ke semua data
	if role == "admin" {
		// Admin dapat mengakses semua data, tanpa pembatasan pada detail_id
	} else if role != "user" {
		c.JSON(403, gin.H{"error": "Forbidden: Invalid role"})
		return
	}

	// Pastikan detail ada
	var detail model.Detail
	if err := config.DB.Preload("Transactions").First(&detail, detail_id).Error; err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Memvalidasi input dengan Middleware ValidateInput.
	var updatedData middleware.DetailSchema
	if err := c.ShouldBindJSON(&updatedData); err != nil {
		errors := middleware.FormatValidationErrors(err)
		c.JSON(400, gin.H{"errors": errors})
		return
	}

	validationErrors := middleware.ValidateInput(updatedData)
	if validationErrors != nil {
		c.JSON(400, gin.H{"errors": validationErrors})
		return
	}

	// Menyimpan status sebelumnya
	previousStatus := detail.Status

	// Jika user dan status adalah pending, izinkan perubahan Out dan Entry
	if role == "user" && detail.Status == "pending" {
		if updatedData.Out != "" {
			detail.Out, _ = time.Parse("2006-01-02", updatedData.Out)
		}
		if updatedData.Entry != "" {
			detail.Entry, _ = time.Parse("2006-01-02", updatedData.Entry)
		}
	}

	// Jika admin, hanya bisa mengubah status
	if role == "admin" {
		if updatedData.Status != "" {
			detail.Status = updatedData.Status
		}

		// Jika status berubah dari 'pending' ke 'loaned', kurangi quantity dari stok item
		if previousStatus == "pending" && detail.Status == "loaned" {
			var item model.Item
			if err := config.DB.First(&item, detail.Transactions[0].ItemID).Error; err != nil {
				c.JSON(404, gin.H{"error": "Item not found"})
				return
			}

			// Kurangi stok jika status berubah dari pending ke loaned
			if item.Stock >= detail.Transactions[0].Quantity {
				item.Stock -= detail.Transactions[0].Quantity
				if err := config.DB.Save(&item).Error; err != nil {
					c.JSON(500, gin.H{"error": "Failed to update item stock"})
					return
				}
			} else {
				c.JSON(400, gin.H{"error": "Not enough stock available"})
				return
			}
		}

		// Jika status berubah dari 'loaned' ke 'return' atau 'pending', kembalikan quantity ke stok
		if previousStatus == "loaned" && (detail.Status == "return" || detail.Status == "pending" || detail.Status == "rejected") {
			var item model.Item
			if err := config.DB.First(&item, detail.Transactions[0].ItemID).Error; err != nil {
				c.JSON(404, gin.H{"error": "Item not found"})
				return
			}

			// Kembalikan stok jika status berubah menjadi 'return' atau 'pending'
			item.Stock += detail.Transactions[0].Quantity
			if err := config.DB.Save(&item).Error; err != nil {
				c.JSON(500, gin.H{"error": "Failed to update item stock"})
				return
			}
		}

		// Jika status berubah dari 'pending' ke 'rejected', tidak ada perubahan stok
		if previousStatus == "pending" && detail.Status == "rejected" {
			// Tidak ada tindakan yang diperlukan, hanya mengubah status
		}
	}

	// Simpan perubahan
	if err := config.DB.Save(&detail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "Detail updated successfully", "detail": detail.ToMap()})
}

func DeleteDetailHandler(c *gin.Context) {
	detailID := c.Param("detail_id")

	// Ambil currentUserID dan role dari context
	currentUserID, exists := c.Get("current_id")
	if !exists {
		c.JSON(401, gin.H{"error": "Unauthorized"})
		return
	}

	role, roleExists := c.Get("role")
	if !roleExists {
		c.JSON(403, gin.H{"error": "Forbidden: Role not found"})
		return
	}

	// Pastikan detail ada
	var detail model.Detail
	if err := config.DB.Preload("Transactions").First(&detail, detailID).Error; err != nil {
		c.JSON(404, gin.H{"error": "Detail not found"})
		return
	}

	// Jika role adalah user, pastikan detail miliknya
	if role == "user" {
		var transaction model.Transaction
		if err := config.DB.Where("detail_id = ? AND user_id = ?", detailID, currentUserID).First(&transaction).Error; err != nil {
			c.JSON(403, gin.H{"error": "Forbidden: You can only delete your own detail"})
			return
		}
	}

	// Periksa status detail
	if detail.Status != "pending" && detail.Status != "rejected" {
		c.JSON(400, gin.H{"error": "Cannot delete detail: Detail status must be pending or rejected"})
		return
	}

	// Hapus transaksi yang terhubung dengan detail_id
	if err := config.DB.Unscoped().Where("detail_id = ?", detailID).Delete(&model.Transaction{}).Error; err != nil {
		c.JSON(500, gin.H{"error": "Failed to delete related transactions"})
		return
	}

	// Hapus detail
	if err := config.DB.Unscoped().Delete(&detail).Error; err != nil {
		c.JSON(500, gin.H{"error": err.Error()})
		return
	}

	c.JSON(200, gin.H{"message": "Detail and related transactions deleted successfully"})
}
